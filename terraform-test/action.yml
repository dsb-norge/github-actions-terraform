name: "Run terraform test"
description: |
  Terraform test for modules.
author: "Artjoms Laivins"

inputs:
  test-file:
    description: Test file to run.
    required: true

outputs:
  exit-code:
    description: The exit code from the terraform test command.
    value: ${{ steps.run-tests.outputs.exit-code }}
  summary:
    description: Summary of the test run.
    value: ${{ steps.run-tests.outputs.summary }}
  report:
    description: Report of the test run.
    value: ${{ steps.run-tests.outputs.report }}
  json:
    description: JSON output of the test run.
    value: ${{ steps.run-tests.outputs.json }}


runs:
  using: "composite"
  steps:
    - id: check-prereqs
      shell: bash
      run: |
        # Make sure terraform is available

        set -o allexport; source "${{ github.action_path }}/helpers.sh"; set +o allexport;

        start-group "check prerequisite: terraform binary"
        if ! command -v terraform version &>/dev/null; then
          log-error "terraform is not available on path, please install using the 'setup-terraform' action!"
          exit 1
        else
          log-info "using $(terraform version)"
        fi
        end-group

    - id: run-tests
      working-directory: ${{ github.workspace }}
      if: steps.init.outcome == 'success'
      shell: bash
      continue-on-error: true
      env:
        TF_IN_AUTOMATION: true
      run: |
        set -o allexport; source "${{ github.action_path }}/helpers.sh"; set +o allexport;
        set -o allexport; source "${{ github.action_path }}/helpers_additional.sh"; set +o allexport;

        TEST_RESULT_JSON="${GITHUB_WORKSPACE}/${{ github.run_id }}-${{ inputs.test-file }}-$(date +%Y%m%d%H%M%S)-test-results.json"
        TEST_REPORT_FILE="${GITHUB_WORKSPACE}/${{ github.run_id }}-${{ inputs.test-file }}-$(date +%Y%m%d%H%M%S)-test-report.txt"
        #Outputs definition
        set-multiline-output 'report' "${TEST_REPORT_FILE}"
        set-multiline-output 'json' "${TEST_RESULT_JSON}"

        TEST_CMD="terraform test --filter=tests/${{ inputs.test-file}} -json"

        log-info "Running test command: ${TEST_CMD}"
        start-group "'terraform test' "
        #Run test
        set -o pipefail
          
        set +e
        ${TEST_CMD} | tee ${TEST_RESULT_JSON}
        TEST_EXIT_CODE=${?}
          
        # remove last line that contains gha debug in when failed.
        if [ "${TEST_EXIT_CODE}" != "0" ]; then
          sed -i '$d' ${TEST_RESULT_JSON}
        fi
        log-multiline "Final JSON output" "$TEST_RESULT_JSON"
        set-output "exit-code" "${TEST_EXIT_CODE}"
        

        TEST_SUMMARY=$(jq '. | select(.type == "test_summary") | .["@message"]' ${TEST_RESULT_JSON})

        log info ""
        log-info "Test summary: ${TEST_SUMMARY}"
        set-output "summary" "${TEST_SUMMARY}"
        if [ "${TEST_EXIT_CODE}" == "0" ]; then
          log-info 'All tests passed! ðŸŽ‰'
        else
          log-error "One or more tests failed, exit code: ${TEST_EXIT_CODE}"
          TEST_RUN_RESULT="failure"
          TEST_EXIT_CODE=-1
        fi

        # Creating report data. 
        declare -a  TESTS_RUNNED=()

        readarray -t TESTS_RUNNED < <(jq '. | select(.type == "test_run") | select(.test_run.progress == "complete" ) | .test_run.run' ${TEST_RESULT_JSON})

        echo "Test result for file: ${{ inputs.test-file }}" > ${TEST_REPORT_FILE}
        echo "overall result: "${TEST_RUN_RESULT}"" >> ${TEST_REPORT_FILE}
        echo "exit code: "${TEST_EXIT_CODE}"" >> ${TEST_REPORT_FILE}
        echo " " >> ${TEST_REPORT_FILE}

        echo "output: " >> ${TEST_REPORT_FILE}

        for test in "${TESTS_RUNNED[@]}"; do
          test=$(sed 's/\"//g' <<< "$test")
          RUN_STATUS=$(queryStatus $test ${TEST_RESULT_JSON})
          #RUN_STATUS=$(jq --arg test_run "$test" '. | select(.type == "test_run") | select(.test_run.run == $test_run) | select(.test_run.progress == "complete") | .test_run.status' $TEST_RESULT_JSON)
          if [ ${RUN_STATUS} == "\"error\"" ]; then
            printf 'Test: "'%s'" -----> '%s' \u274c \n' "${test}" "${RUN_STATUS}" >> ${TEST_REPORT_FILE}
            echo "See error details below: " >> ${TEST_REPORT_FILE}
            echo "  " >> ${TEST_REPORT_FILE}
            FILE=$(jq '. | select(.type == "diagnostic")| .diagnostic.range["filename"]' $TEST_RESULT_JSON)
            RESOURCE=$(jq '. | select(.type == "diagnostic")| .diagnostic["address"]' $TEST_RESULT_JSON)
            MESSAGE=$(jq '. | select(.type == "diagnostic")| .diagnostic["summary"]' $TEST_RESULT_JSON)
            echo "  | File: ${FILE}" >> ${TEST_REPORT_FILE}
            echo "  | Resource: ${RESOURCE}" >> ${TEST_REPORT_FILE}
            echo "  | Message: ${MESSAGE}" >> ${TEST_REPORT_FILE}
            echo "  " >> ${TEST_REPORT_FILE}
          elif 
            [ ${RUN_STATUS} == "\"skip\"" ]; then
            printf 'Test: "'%s'" -----> '%s' \u26a0 \n' "${test}" "${RUN_STATUS}" >> ${TEST_REPORT_FILE}
          else
            printf 'Test: "'%s'" -----> '%s' \u2705 \n' "${test}" "${RUN_STATUS}" >> ${TEST_REPORT_FILE}
          fi
        done

        printSection "Test summary for file: ${TEST_SUMMARY}" >> ${TEST_REPORT_FILE}
          
        end-group
    
        exit ${TEST_EXIT_CODE}
    - id: upload-test-results
      uses: actions/upload-artifact@v4
      with:
        name: test-results-output-${{ inputs.test-file }}
        path: ${{ steps.run-tests.outputs.json }}

    - id: test-status
      if: ( steps.run-tests.outcome == 'failure' || steps.run-tests.outcome == 'cancelled' )
      shell: bash
      run: exit 1

#inputs:
#  working-directory:
#    description: From what directory to invoke terraform.
#    required: true
#  extra-global-args:
#    description: |
#      String with more args to pass to terraform as 'global options', those in front of the test command.
#    required: false
#    default: ""
#  extra-test-args:
#    description: |
#      String with more args to pass to terraform as 'options' to the test command, these are the ones coming after the test command.
#    required: false
#    default: ""
#  fail-on-failed-test:
#    description: |
#      Boolean as string, if 'true' the action will exit with a non-zero exit code.
#    required: false
#    default: "true"
#
#
#outputs:
#  exitcode:
#    description: |
#      The exit code from the terraform test command.
#      Note that 'terraform test' exits with exit code 2 upon success when changes are present,
#      ref. https://www.terraform.io/docs/commands/plan.html#detailed-exitcode
#    value: ${{ steps.plan.outputs.tf-plan-exitcode }}
#  console-output-file:
#    description: "The console output captured during execution of 'terraform plan'."
#    value: ${{ steps.plan.outputs.tf-plan-console-output-file }}
#  terraform-plan-file:
#    description: "The plan file created by the 'terraform plan' command."
#    value: ${{ steps.plan.outputs.tf-plan-tf-output-file }}
#  txt-output-file:
#    description: "The output of the terraform plan in plain txt format, ie. processed by the 'terraform show' command."
#    value: ${{ steps.plan-show.outputs.tf-plan-txt-output-file }}


#runs:
#  using: "composite"
#  steps:
#    - id: test
#      shell: bash
#      working-directory: ${{ inputs.working-directory }}
#      env:
#        TF_IN_AUTOMATION: "true"
#      run: |
#        # run terraform test
#
#        set -o allexport; source "${{ github.action_path }}/helpers.sh"; set +o allexport;
#
#        # PLAN_CONSOLE_OUT_FILE="${GITHUB_WORKSPACE}/tf-plan-console-output-${{ inputs.environment-name }}.txt"
#        # PLAN_TF_OUT_FILE="${GITHUB_WORKSPACE}/tf-plan-${{ inputs.environment-name }}.plan"
#        # #set-output 'tf-plan-console-output-file' "${PLAN_CONSOLE_OUT_FILE}"
#        # set-output 'tf-plan-tf-output-file' "${PLAN_TF_OUT_FILE}"
#
#        TEST_CMD="terraform ${{ inputs.extra-global-args }} test
#        log-info "command string is '${TEST_CMD}'"
#        start-group "'terraform plan' in '$(ws-path $(pwd))'"
#
#        # Need this to properly catch terraform exit code
#        set -o pipefail
#
#        # Github runner gets confused by set commands, make sure 'continue-on-error: true' still applies after 'set -o pipefail'
#        set +e
#        ${PLAN_CMD} 2>&1 | tee ${PLAN_CONSOLE_OUT_FILE}
#        PLAN_EXIT_CODE=${?}
#
#        set-output 'tf-plan-exitcode' "${PLAN_EXIT_CODE}"
#
#        # make sure '2' is consider 'success'
#        # 'terraform plan' exits with exit code 2 upon success when changes are present
#        #   https://www.terraform.io/docs/commands/plan.html#detailed-exitcode
#        if [ "${PLAN_EXIT_CODE}" == "0" ]; then
#          log-info 'successfully planned Terraform configuration, no changes indicated.'
#        elif [ "${PLAN_EXIT_CODE}" == "2" ]; then
#          PLAN_EXIT_CODE=0
#          log-info 'successfully planned Terraform configuration, changes indicated!'
#        else
#          log-error "failed to plan Terraform configuration, exit code: ${PLAN_EXIT_CODE}"
#          PLAN_EXIT_CODE=-1
#        fi
#        end-group
#
#        exit ${PLAN_EXIT_CODE}
#      continue-on-error: true # allow action to continue, execution status is returned by the last step
#    - id: plan-upload
#      if: steps.plan.outcome != 'cancelled' && steps.plan.outcome != 'skipped'
#      uses: actions/upload-artifact@v4
#      with:
#        name: ${{ inputs.environment-name }}-terraform-plan-console-output
#        path: ${{ steps.plan.outputs.tf-plan-console-output-file }}
#      continue-on-error: true # allow action to continue, execution status is returned by the last step
#    - id: plan-show
#      if: steps.plan.outcome == 'success'
#      shell: bash
#      working-directory: ${{ inputs.working-directory }}
#      run: |
#        # create plan.txt file
#
#        set -o allexport; source "${{ github.action_path }}/helpers.sh"; set +o allexport;
#
#        start-group "output the plan as txt"
#        PLAN_TF_OUT_FILE="${{ steps.plan.outputs.tf-plan-tf-output-file }}"
#        PLAN_TXT_OUT_FILE="${GITHUB_WORKSPACE}/tf-plan-${{ inputs.environment-name }}.txt"
#        set-output 'tf-plan-txt-output-file' "${PLAN_TXT_OUT_FILE}"
#        terraform show -no-color ${PLAN_TF_OUT_FILE} 2>&1 | tee ${PLAN_TXT_OUT_FILE}
#        end-group
#      continue-on-error: true # allow action to continue, execution status is returned by the last step
#    - id: plan-status
#      if: |
#        inputs.fail-on-failed-plan == 'true'
#        && ( steps.plan.outcome == 'failure' || steps.plan.outcome == 'cancelled' )
#      shell: bash
#      run: exit 1
#